package com.example.apipractice

import io.circe._
import io.circe.generic.auto._
import io.circe.syntax._
import io.circe.literal._

import cats.syntax.show._

import org.http4s._
import org.http4s.circe._
import org.http4s.server._
import org.http4s.dsl._

import scalaz.{\/, -\/, \/-}

object HelloWorld {

  case class Greeting(greeting: String)
  // You can embed one type in another type to model nested JSON objects
  case class ExtendedGreeting(greeting: Greeting, language: String)

  // This is unnecessary, as the autogenerated encoder would do
  // the same thing 
  implicit val ExtendedGreetingEncoder: Encoder[ExtendedGreeting] =
    Encoder.instance { hello: ExtendedGreeting =>
      json"""
      {"language": ${hello.language},
       "greeting": {"greeting": ${hello.greeting.greeting }}}"""
    }

  // This is unnecessary, as the autogenerated decoder would do
  // the same thing. However, if you do need to use a custom decoder
  // e.g. to handle complex oddness in the format, this how
  // You'll want to consult the Circe documentation for more details
  implicit val ExtendedGreetingDecoder: Decoder[ExtendedGreeting] =
    Decoder.instance { hello: io.circe.HCursor =>
      for {
        language <- hello.downField("language").as[String]
        greeting <- hello.downField("greeting").as[Greeting]
      } yield ExtendedGreeting(greeting, language)
    }

  // The body of the service is a partial function
  val service = HttpService {
    // pure example
    case GET -> Root / "hello" / name =>
      Ok(Json.obj("message" -> Json.fromString(s"Hello, ${name}")))

    case request @ POST -> Root / "hello" / name =>
      for {
        // Decode a user request - simplest way to access the request body
	greeting <- request.as(jsonOf[Greeting])
        resp <- Ok(Json.obj("message" -> Json.fromString(s"${greeting.greeting}, ${name}")))
      } yield resp

    case request @ PUT -> Root / "hello" / name => {
      // request.as returns a Task; attempt converts it to a task that
      // will return a (scalaz) Either (\/) of either a throwable or the result
      // Use flatMap here rather than map, because flatMap allows you to return
      // "plain" objects rather than objects wrapped in a Task
      // If you're integrating with FS2-based code, map may be better
      request.as(jsonOf[ExtendedGreeting]).attempt.flatMap {
        // check that the exception is caused by a decoding failure
        // and use the Circe show capabilities to print out a vaguely
        // useful error message in the response
        case -\/(f) => f.getCause match {
          case (d: DecodingFailure) => BadRequest(d.show)
          case _ => BadRequest(f.toString)
        }
        // Handle the happy path
        case \/-(greeting) =>  Ok(Json.obj("message" -> Json.fromString(s"${greeting.greeting.greeting}, ${name}")))
      }
    }
  }
}
